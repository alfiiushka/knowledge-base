## Ссылки или значения?

Допустим, мы имеем метод, входным параметром которого является объект.  
Внимание, вопрос: **по ссылке или по значению передается объект в Java?**

Итак, давайте разбираться! 

Начнем мы с...С++. 

Допустим есть следующий метод:
    
    
     int swap(int a, int b) {
         int temp = a;
         a = b;
         b = temp;
     }
     
     int main() {
         int x = 10;
         int y = 5;
         swap(x, y);
         
         cout << x << " " << y << endl;
         
         return 0;
     }

Как вы думаете, что выведет данная программа?

Заметим, что в данном случае a и b - это отдельные переменные. При выполнении операции  swap(x, y)  значение 10 копируется в переменную a, 
значение 5 - в переменную b. При этом x и y  - это отдельные переменные. 
Таким образом, при выполнении данного кода ни в C++, ни в Java значения x и y не изменятся, так как a и b - это копии. 
Итак, это называется передача аргумента в параметр по значению. Следственно, данная программа выведет: 10 5.

Теперь рассмотрим немного другой вариант.


     int swapInPointers(int &a, int &b) {
         int temp = a;
         a = b;
         b = temp;
     }
     
     int main() {
         int x = 10;
         int y = 5;
         swap(x, y);
         
         cout << x << " " << y << endl;
         
         return 0;
     }
     
Что же будет выведено в консоль в данном случае? 

Логично предположить, что в данном случае переменные x и y изменят свои значения. И если вы сделали именно такое предположение, 
то вы оказались абсолютно правыми. В данном случае происходит передача аргумента в параметр по ссылке. 
Таким образом, в этом случае программа выведет: 5 10. 


Давайте поговорим о том, что это такое и как оно работает. Мы можем сделать следующее: 
     
     
     int main() {
         int p = 22;
         
         cout << "p value " << p << endl;
         
         return 0;
     }
     
Думаю, все догадались, что на экран выведется “22”. Поехали дальше. 
У данной переменной мы можем “взять” адрес, то есть узнать, какой именно байт держит в себе значение переменной p. 
Для этого используется операция &. Соответственно написав следующие строчки, вы увидите адрес:     
     
     cout << "p address " << &p << endl;
     
Не  ленитесь, и проверьте данную информацию, вдруг я вас обманываю;-P

Допустим, вы поверили мне на слово и  хотите сохранить полученный вами адрес. Это можно сделать следующим образом:     
     
     int *pPointer = &p;
     
Вы спросите, а может и не спросите, почему перед именем переменной появилась * . На всякий случай всё-таки поясню - это обозначение указателя. 
В данном случае pPointer - это указатель - переменная, которая содержит адрес другой переменной. 
При этом очевидно, что следующая строка кода выведет адрес байта:  

     cout << pPointer << endl;
     
в то время как следующее выведет на экран значение самой переменной p, то есть 22.     
     
     cout << *pPointer;
     
Сейчас мы с вами перепишем код так, чтобы в нем использовались только что изученные нами указатели.
     
     int swapWithStarts(int *a, int *b) {
         int temp = *a;
         *a = *b;
         *b = temp;
     }
     
     int main() {
         int x = 10;
         int y = 5;
         swapWithStarts(&x, &y);
         
         cout << x << " " << y << endl;
         
         return 0;
     }
     
То есть в метод мы передали адреса байтов, в которых лежат значения переменных x  и y, а сам метод работает уже с указателями на переменные. 
Естественно, что в этом случае переменные также обменяются своими значениями.

Поехали дальше, дальше веселее!
     
     struct User {
         int age;
     };
     
     void olding(User user) {
         user.age +=1;
     }
     
     int main() {
         User user;
         user.age = 10;
         olding(user);
         
         cout << user.age << endl;
         
         return 0;
     }

Думаю, вопрос, который я задам, уже понятен. Что выведется пользователю в данном случае? 
Могу сказать, что в данном случае код ничем не отличается от первого примера с функцией swap. Мы передали в метод просто копию переменной. 
Нет никакой разницы, что мы передаем: структуру или обычную переменную. То есть произошла передача по значению. Результат на экране: 10.

Перепишем код так, чтобы он реализовывал передачу по ссылке. 
     
     struct User {
         int age;
     };
     
     void olding(User *user) {
         (*user).age += 1;
     }
     
     int main() {
         User user;
         user.age = 10;
         olding(&user);
         
         cout << user.age << endl;
         
         return 0;
     }

В этом случае в качестве параметра в методе olding выступает указатель - *user . Соответственно, из тела метода main теперь передается адрес переменной, 
то есть &user. Пользователю на экран будет выведено: 11.

Тело метода olding можно записать в более привычном стиле, а именно:
     
     void olding(User *user) {
         user->age +=1;
     }
     
Теперь обратимся к Java.

     struct User {
         int age;
     };
     
     void olding(User *user) {
         user->age +=1;
     }
     
     int main() {
         User *user;
         user = new User;
         user->age = 10;
         olding(user);
         
         cout << user->age;
         
         return 0;
     }

Да, да, код опять на плюсах, но вы можете заметить, что теперь в коде нет &. Хотя код по-прежнему является реализацией передачи по ссылке.
Как же это получилось? В данном примере мы объявили вместо обычной переменной, указатель(то есть user - это теперь переменная-указатель).   
Это позволило нам просто “программировать”, не заморачиваясь с адресами байтов. А самое интересное, что это Java, просто в Java скрыли *.   
В Java любая объектная переменная является указателем, и она указывает на какой-либо объект. Объектная переменная всегда содержит значение, 
но в качестве значения выступает ссылка. Таким образом, происходит передача не по ссылке, а **по значению**!   
В Java всё передаётся по значению, ВСЕГДА. В ней в принципе нет такой возможности, как передача по ссылке, потому что нет оператора **&**. 
Это обеспечивает безопасную работу с памятью. 

За подробное просвещение в дебрях языка Java выражается благодарность Марселю Сидикову!:)
